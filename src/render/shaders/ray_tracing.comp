#version 430

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(rgba8, binding = 0) uniform image2D outputImage;

layout(std430, binding = 1) readonly buffer SceneData {
    vec4 spheres[];
};

layout(std430, binding = 2) buffer RNGStates {
    uint rngStates[];
};

// Uniforms for camera and rendering parameters
uniform vec3 cameraPosition;
uniform vec3 cameraLowerLeft;
uniform vec3 cameraHorizontal;
uniform vec3 cameraVertical;
uniform int maxDepth;
uniform int samplesPerPixel;
uniform int imageWidth;
uniform int imageHeight;

// Random number generation
uint rngState = 1u;

uint rng() {
    rngState ^= rngState << 13;
    rngState ^= rngState >> 17;
    rngState ^= rngState << 5;
    return rngState;
}

float randomFloat() {
    return float(rng()) / 4294967295.0;
}

vec3 randomInUnitSphere() {
    vec3 p;
    int attempts = 0;
    do {
        p = 2.0 * vec3(randomFloat(), randomFloat(), randomFloat()) - vec3(1.0);
        attempts++;
    } while (dot(p, p) >= 1.0 && attempts < 8);
    return p;
}

vec3 randomUnitVector() {
    return normalize(randomInUnitSphere());
}

// Ray structure
struct Ray {
    vec3 origin;
    vec3 direction;
};

vec3 rayAt(Ray ray, float t) {
    return ray.origin + t * ray.direction;
}

// Material and hit information
struct HitRecord {
    vec3 point;
    vec3 normal;
    float t;
    bool frontFace;
    vec3 albedo;
    float emission;
};

bool hitSphere(vec3 center, float radius, Ray ray, float tMin, float tMax, out HitRecord rec) {
    vec3 oc = ray.origin - center;
    float a = dot(ray.direction, ray.direction);
    float halfB = dot(oc, ray.direction);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = halfB * halfB - a * c;
    
    if (discriminant < 0.0) return false;
    
    float sqrtd = sqrt(discriminant);
    float root = (-halfB - sqrtd) / a;
    
    if (root < tMin || tMax < root) {
        root = (-halfB + sqrtd) / a;
        if (root < tMin || tMax < root) return false;
    }
    
    rec.t = root;
    rec.point = rayAt(ray, rec.t);
    vec3 outwardNormal = (rec.point - center) / radius;
    rec.frontFace = dot(ray.direction, outwardNormal) < 0.0;
    rec.normal = rec.frontFace ? outwardNormal : -outwardNormal;
    
    return true;
}

bool hitWorld(Ray ray, float tMin, float tMax, out HitRecord rec) {
    HitRecord tempRec;
    bool hitAnything = false;
    float closestSo = tMax;
    
    // Iterate through spheres (each sphere is 2 vec4s: center+radius, albedo+emission)
    int sphereCount = spheres.length() / 2;
    for (int i = 0; i < sphereCount; i++) {
        vec4 sphereData = spheres[i * 2];
        vec4 materialData = spheres[i * 2 + 1];
        
        vec3 center = sphereData.xyz;
        float radius = sphereData.w;
        
        if (hitSphere(center, radius, ray, tMin, closestSo, tempRec)) {
            hitAnything = true;
            closestSo = tempRec.t;
            rec = tempRec;
            rec.albedo = materialData.xyz;
            rec.emission = materialData.w;
        }
    }
    
    return hitAnything;
}

// Non-recursive ray color using iterative approach
vec3 rayColor(Ray initialRay) {
    vec3 color = vec3(0.0);
    vec3 attenuation = vec3(1.0);
    Ray ray = initialRay;
    
    for (int depth = 0; depth < maxDepth; depth++) {
        HitRecord rec;
        if (hitWorld(ray, 0.001, 1000000.0, rec)) {
            // Handle emissive materials (lights)
            if (rec.emission > 0.0) {
                color += attenuation * rec.albedo * rec.emission;
                break;
            }
            
            // Lambertian scattering
            attenuation *= 0.5 * rec.albedo;
            vec3 target = rec.point + rec.normal + randomUnitVector();
            ray.origin = rec.point;
            ray.direction = target - rec.point;
        } else {
            // Sky gradient
            vec3 unitDirection = normalize(ray.direction);
            float t = 0.5 * (unitDirection.y + 1.0);
            color += attenuation * ((1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0));
            break;
        }
    }
    
    return color;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    
    // Check bounds
    if (pixel.x >= imageWidth || pixel.y >= imageHeight) return;
    
    // Initialize RNG state for this pixel
    int pixelIndex = pixel.y * imageWidth + pixel.x;
    rngState = rngStates[pixelIndex];
    if (rngState == 0u) rngState = uint(pixelIndex + 1);
    
    vec3 color = vec3(0.0);
    
    // Multi-sampling
    for (int s = 0; s < samplesPerPixel; s++) {
        // Anti-aliasing with random sampling
        float u = (float(pixel.x) + randomFloat()) / float(imageWidth);
        float v = (float(pixel.y) + randomFloat()) / float(imageHeight);
        
        // Generate ray using GPU camera model
        Ray ray;
        ray.origin = cameraPosition;
        ray.direction = cameraLowerLeft + u * cameraHorizontal + v * cameraVertical - cameraPosition;
        
        color += rayColor(ray);
    }
    
    // Average the samples and gamma correct
    color /= float(samplesPerPixel);
    color = sqrt(color); // Simple gamma correction
    
    // Store the updated RNG state
    rngStates[pixelIndex] = rngState;
    
    // Output final color
    imageStore(outputImage, pixel, vec4(color, 1.0));
}