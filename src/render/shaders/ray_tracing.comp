#version 430

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(rgba8, binding = 0) uniform image2D outputImage;

layout(std430, binding = 1) readonly buffer SceneData {
    vec4 spheres[]; // Now contains both spheres and cubes - 3 vec4s per primitive
};

layout(std430, binding = 2) buffer RNGStates {
    uint rngStates[];
};

// Uniforms for camera and rendering parameters
uniform vec3 cameraPosition;
uniform vec3 cameraLowerLeft;
uniform vec3 cameraHorizontal;
uniform vec3 cameraVertical;
uniform int maxDepth;
uniform int samplesPerPixel;
uniform int imageWidth;
uniform int imageHeight;

// Random number generation
uint rngState = 1u;

uint rng() {
    rngState ^= rngState << 13;
    rngState ^= rngState >> 17;
    rngState ^= rngState << 5;
    return rngState;
}

float randomFloat() {
    return float(rng()) / 4294967295.0;
}

vec3 randomInUnitSphere() {
    vec3 p;
    int attempts = 0;
    do {
        p = 2.0 * vec3(randomFloat(), randomFloat(), randomFloat()) - vec3(1.0);
        attempts++;
    } while (dot(p, p) >= 1.0 && attempts < 8);
    return p;
}

vec3 randomUnitVector() {
    return normalize(randomInUnitSphere());
}

vec3 reflect(vec3 v, vec3 n) {
    return v - 2.0 * dot(v, n) * n;
}

// Ray structure
struct Ray {
    vec3 origin;
    vec3 direction;
};

vec3 rayAt(Ray ray, float t) {
    return ray.origin + t * ray.direction;
}

// Material and hit information
struct HitRecord {
    vec3 point;
    vec3 normal;
    float t;
    bool frontFace;
    vec3 albedo;
    float materialFlags; // 0.0=diffuse, 1.0=metallic, >1.0=emission intensity
};

bool hitSphere(vec3 center, float radius, Ray ray, float tMin, float tMax, out HitRecord rec) {
    vec3 oc = ray.origin - center;
    float a = dot(ray.direction, ray.direction);
    float halfB = dot(oc, ray.direction);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = halfB * halfB - a * c;
    
    if (discriminant < 0.0) return false;
    
    float sqrtd = sqrt(discriminant);
    float root = (-halfB - sqrtd) / a;
    
    if (root < tMin || tMax < root) {
        root = (-halfB + sqrtd) / a;
        if (root < tMin || tMax < root) return false;
    }
    
    rec.t = root;
    rec.point = rayAt(ray, rec.t);
    vec3 outwardNormal = (rec.point - center) / radius;
    rec.frontFace = dot(ray.direction, outwardNormal) < 0.0;
    rec.normal = rec.frontFace ? outwardNormal : -outwardNormal;
    
    return true;
}

bool hitCube(vec3 center, float size, Ray ray, float tMin, float tMax, out HitRecord rec) {
    // Axis-aligned bounding box intersection
    vec3 rayInv = 1.0 / ray.direction;
    vec3 minBounds = center - vec3(size * 0.5);
    vec3 maxBounds = center + vec3(size * 0.5);
    
    vec3 t1 = (minBounds - ray.origin) * rayInv;
    vec3 t2 = (maxBounds - ray.origin) * rayInv;
    
    vec3 tNear = min(t1, t2);
    vec3 tFar = max(t1, t2);
    
    float tNearMax = max(max(tNear.x, tNear.y), tNear.z);
    float tFarMin = min(min(tFar.x, tFar.y), tFar.z);
    
    if (tNearMax > tFarMin || tFarMin < tMin || tNearMax > tMax) {
        return false;
    }
    
    float t = (tNearMax > tMin) ? tNearMax : tFarMin;
    if (t < tMin || t > tMax) return false;
    
    rec.t = t;
    rec.point = rayAt(ray, t);
    
    // Calculate normal based on which face was hit
    vec3 localPoint = rec.point - center;
    vec3 absLocal = abs(localPoint);
    float maxComponent = max(max(absLocal.x, absLocal.y), absLocal.z);
    
    if (maxComponent == absLocal.x) {
        rec.normal = vec3(sign(localPoint.x), 0.0, 0.0);
    } else if (maxComponent == absLocal.y) {
        rec.normal = vec3(0.0, sign(localPoint.y), 0.0);
    } else {
        rec.normal = vec3(0.0, 0.0, sign(localPoint.z));
    }
    
    rec.frontFace = dot(ray.direction, rec.normal) < 0.0;
    if (!rec.frontFace) rec.normal = -rec.normal;
    
    return true;
}

bool hitWorld(Ray ray, float tMin, float tMax, out HitRecord rec) {
    HitRecord tempRec;
    bool hitAnything = false;
    float closestSo = tMax;
    
    // Iterate through primitives (each primitive is 3 vec4s: center+size, albedo+material, type+padding)
    int primitiveCount = spheres.length() / 3;
    for (int i = 0; i < primitiveCount; i++) {
        vec4 positionData = spheres[i * 3];
        vec4 materialData = spheres[i * 3 + 1];
        vec4 typeData = spheres[i * 3 + 2];
        
        vec3 center = positionData.xyz;
        float size = positionData.w;
        float primitiveType = typeData.x;
        
        bool hit = false;
        if (primitiveType < 0.5) {
            // Sphere
            hit = hitSphere(center, size, ray, tMin, closestSo, tempRec);
        } else {
            // Cube
            hit = hitCube(center, size, ray, tMin, closestSo, tempRec);
        }
        
        if (hit) {
            hitAnything = true;
            closestSo = tempRec.t;
            rec = tempRec;
            rec.albedo = materialData.xyz;
            rec.materialFlags = materialData.w;
        }
    }
    
    return hitAnything;
}

// Non-recursive ray color using iterative approach
vec3 rayColor(Ray initialRay) {
    vec3 color = vec3(0.0);
    vec3 attenuation = vec3(1.0);
    Ray ray = initialRay;
    
    for (int depth = 0; depth < maxDepth; depth++) {
        HitRecord rec;
        if (hitWorld(ray, 0.001, 1000000.0, rec)) {
            // Handle emissive materials (lights)
            if (rec.materialFlags > 1.5) {
                color += attenuation * rec.albedo * rec.materialFlags;
                break;
            }
            
            if (rec.materialFlags > 0.5) {
                // Metallic material - reflection
                vec3 reflected = reflect(normalize(ray.direction), rec.normal);
                // Add small amount of fuzziness for realistic metal
                reflected = reflected + randomInUnitSphere() * 0.1;
                
                if (dot(reflected, rec.normal) > 0.0) {
                    attenuation *= rec.albedo;
                    ray.origin = rec.point;
                    ray.direction = reflected;
                } else {
                    // Absorbed
                    break;
                }
            } else {
                // Diffuse material - Lambertian scattering
                attenuation *= rec.albedo;
                vec3 target = rec.point + rec.normal + randomUnitVector();
                ray.origin = rec.point;
                ray.direction = target - rec.point;
            }
        } else {
            // Sky gradient
            vec3 unitDirection = normalize(ray.direction);
            float t = 0.5 * (unitDirection.y + 1.0);
            color += attenuation * ((1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0));
            break;
        }
    }
    
    return color;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    
    // Check bounds
    if (pixel.x >= imageWidth || pixel.y >= imageHeight) return;
    
    // Initialize RNG state for this pixel
    int pixelIndex = pixel.y * imageWidth + pixel.x;
    rngState = rngStates[pixelIndex];
    if (rngState == 0u) rngState = uint(pixelIndex + 1);
    
    vec3 color = vec3(0.0);
    
    // Multi-sampling
    for (int s = 0; s < samplesPerPixel; s++) {
        // Anti-aliasing with random sampling
        float u = (float(pixel.x) + randomFloat()) / float(imageWidth);
        float v = (float(pixel.y) + randomFloat()) / float(imageHeight);
        
        // Generate ray using GPU camera model
        Ray ray;
        ray.origin = cameraPosition;
        ray.direction = cameraLowerLeft + u * cameraHorizontal + v * cameraVertical - cameraPosition;
        
        color += rayColor(ray);
    }
    
    // Average the samples and gamma correct
    color /= float(samplesPerPixel);
    color = sqrt(color); // Simple gamma correction
    
    // Store the updated RNG state
    rngStates[pixelIndex] = rngState;
    
    // Output final color
    imageStore(outputImage, pixel, vec4(color, 1.0));
}